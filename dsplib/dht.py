import numpy as np
from numba import njit
import tqdm

from dsplib.utils import *

def hilbert_ir(M):
    '''
    Generates the impulse response of an M-point discrete Hilbert transform.

    Parameters
    ----------
    M : int
        The length of the impulse response.

    Returns
    -------
    h : float[M]
        The M-point Hilbert transform impulse response.
    '''

    ns = np.arange(M)
    h = np.zeros(M)

    for n in ns:
        if n % 2 == 0:
            continue
        else:
            # This can be found by recalling that a Hilbert transformer is a 90 degree phase shifter and finding
            # the associated discrete-time impulse response of such a filter. As M goes to infinity we get the
            # usual expression for the discrete time Hilbert transform impulse response
            h[n] = 2 * np.sin(np.pi * n / 2) * np.sin(np.pi * (M / 2 - 1) * n / M) / np.sin(np.pi * n / M) / M

    return h


def dht(x):
    '''
    Computes the discrete Hilbert transform of a signal. This is essentially the imaginary
    part of the analytic signal, which is the FFT of the original signal with all negative
    frequencies zeroed out. This is a circular convolution with our signal and the impulse
    response generated by hir(M)

    Parameters
    ----------
    x : float[N]
        The signal to take the hilbert transform of.

    Returns
    -------
    xh : float[N]
        The Hilbert transform of x.
    '''

    N = len(x)
    h = hilbert_ir(N)
    return convolve(np.append(x, x), h)[N:-N + 1]


def analytic(x):
    '''
    Computes the analytic signal of x, adding an imaginary part that is the Hilbert transform
    of the real part.

    Parameters
    ----------
    x : float[N]
        The original, real signal.

    Returns
    -------
    xa : float[N]
        The analytic, complex signal.
    '''

    return x + 1j * dht(x)
